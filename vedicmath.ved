#increases number by one
सूत्र एकाधिकेन(अंक){
    फल अंक+1;
}

# decreases number by one
सूत्र एकन्यूनेन(अंक){
    फल अंक-1;
}

#checks whether the number is even
सूत्र संख्या_युग्म(अंक){
    फल (अंक % 2 == 0);
}

#checks whether the number is odd
सूत्र संख्या_अयुग्म(अंक){
    फल (अंक % 2 != 0);
}

#calculates simple amount of simple intrest
सूत्र मिश्रधन(म,द,स){
  फल म+(म*द*स/१००);
}

# simple division of numbers
सूत्र संख्या_भाग(अंश, हर) {
    यदि (हर == 0) {
        वद("त्रुटि: शून्य से भाग नहीं किया जा सकता");
        फल 0;
    }
    फल अंश / हर;
}

#increases a number with a power of other
सूत्र घातक(base, exponent){
  मान answer = base;
  चक्र(मान अ = ०; अ < exponent-1; अ = अ+ १){
    answer = answer*base;
  }
  फल (answer);
}

#reciprocals a number
सूत्र परस्परम(number){
  फल 1/number;
}

#returns the factor of the number
सूत्र गुणक(number){
  मान factor = [];
  चक्र(मान अ = 1; अ <= number; अ = अ+ १){
    यदि (number%अ == 0) {
       factor.आगम(अ);
    }
  }
  फल (factor);
}

#checks whether the number is prime or not
सूत्र अभाज्य_संख्या(number){
  मान factor = गुणक(number);
   यदि (कुल(factor) == 2) {
      फल सत्य;
   }
   अथ {
     फल असत्य;
   }
}

#return the nearest lower integer
सूत्र अधःस्थमान(संख्या) {
  मान अ;

  यदि (संख्या >= 0) {
    अ = 0;
    चक्र(मान अ = 0; अ <= संख्या+1; अ = अ + 1) {
      यदि (अ > संख्या) {
        फल (अ - 1);
      }
    }
    फल अ;
  }
  अथ {
    अ = 0;
    चक्र(मान अ = 0; अ >= संख्या-1; अ = अ - 1) {
      यदि (अ < संख्या) {
        फल (अ);
      }
    }
    फल अ;
  }

}

#return the nearest higher integer
सूत्र अधिकतमं_पूर्णसंख्या(संख्या) {
  मान अ;

  यदि (संख्या >= 0) {
    अ = 0;
    चक्र(मान अ = 0; अ <= संख्या + 1; अ = अ + 1) {
      यदि (अ >= संख्या) {
        फल अ;
      }
    }
  }
  अथ {
    अ = 0;
    चक्र(मान अ = 0; अ >= संख्या - 1; अ = अ - 1) {
      यदि (अ <= संख्या) {
        फल अ+1;
      }
    }
  }
}

#rounds off the decimal place to nearest integer
सूत्र परिगणना(संख्या) {
  यदि (संख्या >= 0) {
    मान base = अधःस्थमान(संख्या);
    मान decimal = संख्या - base;
    यदि (decimal >= 0.5) {
      फल base+1;
    }
    अथ {
      फल base;
    }
  }
  अथ {
    मान base = अधिकतमं_पूर्णसंख्या(संख्या);
    मान decimal = संख्या - base;
    यदि (-decimal >= 0.5) {
      फल base-1;
    }
    अथ {
      फल base;
    }
}
}

#divides one number from other till k decimal places
सूत्र संख्या_भाग_तक(अंश, हर, स्थान) {
    यदि (हर == 0) {
        वद("त्रुटि: शून्य से भाग नहीं किया जा सकता");
        फल 0;
    }

    यदि (स्थान == न) {
        स्थान = 2;
    }

    मान ऋणात्मक = असत्य;
    यदि ((अंश < 0 && हर > 0) || (अंश > 0 && हर < 0)) {
        ऋणात्मक = सत्य;
    }

    मान अंश_मूल = अंश;
    यदि (अंश < 0) {
        अंश_मूल = -अंश;
    }

    मान हर_मूल = हर;
    यदि (हर < 0) {
        हर_मूल = -हर;
    }

    मान भागफल = अंश_मूल / हर_मूल;
    मान स्केल = घातक(10, स्थान);
    मान temp = भागफल * स्केल;

    मान पूर्णांक_मान = परिगणना(temp);
    मान परिणाम = पूर्णांक_मान / स्केल;

    यदि (ऋणात्मक) {
        फल -परिणाम;
    } अथ {
        फल परिणाम;
    }
}

#calculates the round off till a fixed decimal places
सूत्र परिगणना_दशांश(संख्या, स्थान) {
  मान स्केल = घातक(10, स्थान);
  मान गुणनफल = संख्या * स्केल;
  मान पूर्णांक_मान = परिगणना(गुणनफल);
  फल पूर्णांक_मान / स्केल;
} 

#approximatre value of pie as constant
 मान पाई = 3.141592653589793;

#converts degree to radian
सूत्र डिग्री_से_रैडियन(डिग्री) {
  फल (डिग्री * पाई) / 180;
}

# it calculates the the square root of a number till k decimal places
सूत्र वर्गमूल(x) {
  यदि (x < 0) {
    वद("त्रुटि: ऋणात्मक संख्या का वर्गमूल नहीं हो सकता");
    फल 0;
  }

  यदि (x == 0 || x == 1) {
    फल x;
  }

  मान अनुमान = x / 2;
  मान अ = 0;

  चक्र(मान अ = 0; अ < 20; अ = अ + 1) {
    अनुमान = (अनुमान + (x / अनुमान)) / 2;
  }

  फल अनुमान;
} 

#a function which calculates factorial
सूत्र कृमि(संख्या) {
  मान परिणाम = 1;
  चक्र(मान अ = 1; अ <= संख्या; अ = अ + 1) {
    परिणाम = परिणाम * अ;
  }
  फल परिणाम;
}

#the code below works for providing the most accurate value of trigonometric ratios
सूत्र साइन_पूर्वनिर्धारित(डिग्री) {
  यदि (डिग्री == 0) फल 0;
  यदि (डिग्री == 30) फल 0.5;
  यदि (डिग्री == 45) फल 0.7071;
  यदि (डिग्री == 60) फल 0.8660;
  यदि (डिग्री == 90) फल 1;
  फल न;
}
सूत्र कोसाइन_पूर्वनिर्धारित(डिग्री) {
  यदि (डिग्री == 0) फल 1;
  यदि (डिग्री == 30) फल 0.8660;
  यदि (डिग्री == 45) फल 0.7071;
  यदि (डिग्री == 60) फल 0.5;
  यदि (डिग्री == 90) फल 0;
  फल न;
}

सूत्र साइन(डिग्री) {
  मान टेबल_मान = साइन_पूर्वनिर्धारित(डिग्री);
यदि (टेबल_मान != न) {
  फल टेबल_मान;
}
  # Normalize angle to 0–360°
  डिग्री = डिग्री % 360;
  
  # Convert to radians
  मान x = डिग्री_से_रैडियन(डिग्री);
  
  # Adjust based on sine wave symmetry
  मान sign = 1;
  यदि (डिग्री > 180) {
    डिग्री = 360 - डिग्री;
    x = डिग्री_से_रैडियन(डिग्री);
    sign = -1;
  }
  अथ यदि (डिग्री > 90) {
    डिग्री = 180 - डिग्री;
    x = डिग्री_से_रैडियन(डिग्री);
  }

  # Calculate sine using Taylor series: x - x³/3! + x⁵/5! - x⁷/7! + x⁹/9!
  मान x3 = घातक(x, 3);
  मान x5 = घातक(x, 5);
  मान x7 = घातक(x, 7);
  मान x9 = घातक(x, 9);

  मान term1 = x;
  मान term2 = x3 / कृमि(3);
  मान term3 = x5 / कृमि(5);
  मान term4 = x7 / कृमि(7);
  मान term5 = x9 / कृमि(9);

  मान result = term1 - term2 + term3 - term4 + term5;

  फल sign * result;
}

#the code below calculates the value of cos
सूत्र कोसाइन(डिग्री) {
  मान पूर्व = कोसाइन_पूर्वनिर्धारित(डिग्री);
यदि (पूर्व != न) {
  फल पूर्व;
}
  # Normalize angle to 0–360°
  डिग्री = डिग्री % 360;
  
  # Convert to radians
  मान x = डिग्री_से_रैडियन(डिग्री);

  # Adjust sign based on quadrant
  मान sign = 1;
  यदि (डिग्री > 180) {
    डिग्री = 360 - डिग्री;
    x = डिग्री_से_रैडियन(डिग्री);
    sign = -1;
  }
  अथ यदि (डिग्री > 90) {
    डिग्री = 180 - डिग्री;
    x = डिग्री_से_रैडियन(डिग्री);
    sign = -1;
  }

  # Taylor series terms: 1 - x²/2! + x⁴/4! - x⁶/6! + x⁸/8!
  मान x2 = घातक(x, 2);
  मान x4 = घातक(x, 4);
  मान x6 = घातक(x, 6);
  मान x8 = घातक(x, 8);

  मान term1 = 1;
  मान term2 = x2 / कृमि(2);
  मान term3 = x4 / कृमि(4);
  मान term4 = x6 / कृमि(6);
  मान term5 = x8 / कृमि(8);

  मान result = term1 - term2 + term3 - term4 + term5;

  फल sign * result;
}

# tan(θ) = sin(θ) / cos(θ)
सूत्र टेन(डिग्री) {
  मान sin_val = साइन(डिग्री);
  मान cos_val = कोसाइन(डिग्री);

  यदि (cos_val == 0) {
    वद("त्रुटि: शून्य से भाग नहीं किया जा सकता");
    फल 0;
  }

  फल sin_val / cos_val;
}

# cot(θ) = cos(θ) / sin(θ)
सूत्र कोट(डिग्री) {
  मान sin_val = साइन(डिग्री);
  मान cos_val = कोसाइन(डिग्री);

  यदि (sin_val == 0) {
    वद("त्रुटि: शून्य से भाग नहीं किया जा सकता");
    फल 0;
  }

  फल cos_val / sin_val;
}

# sec(θ) = 1 / cos(θ)
सूत्र सेक(डिग्री) {
  मान cos_val = कोसाइन(डिग्री);

  यदि (cos_val == 0) {
    वद("त्रुटि: शून्य से भाग नहीं किया जा सकता");
    फल 0;
  }

  फल 1 / cos_val;
}

# cosec(θ) = 1 / sin(θ)
सूत्र कोसेक(डिग्री) {
  मान sin_val = साइन(डिग्री);

  यदि (sin_val == 0) {
    वद("त्रुटि: शून्य से भाग नहीं किया जा सकता");
    फल 0;
  }

  फल 1 / sin_val;
}
  